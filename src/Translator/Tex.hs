{-# LANGUAGE QuasiQuotes, OverloadedStrings #-}

module Translator.Tex (
  texBare
, tex
) where

import           Control.Monad.Reader (asks)
import qualified Data.Text.Lazy as T
import           Data.Text.Lazy (Text)
import           Text.Printf (printf)
import           Text.RawString.QQ
import           Prelude hiding (print)

import           Parser.Token (Token(..))
import           Parser.MetaInfo (MetaInfo(..), getTitle, getLitAuthor) 
import           Monad.Parakeet (Parakeet)
import           Options (Options(..))

header :: Text
header = "% automatically generated by parakeet"

template :: Text
template = [r|

\documentclass{article}

\usepackage[a4paper]{geometry}

\usepackage{xeCJK}
\usepackage{ruby}

\setCJKmainfont{MS Mincho}
\setCJKsansfont{MS Gothic}

\linespread{2.0}
\setlength\parindent{0.0pt}
\renewcommand\rubysep{-1.7ex}

$metainfo$

\begin{document}

$body$

\end{document}

|]

build :: Bool -> Int -> String -> String
build useVerb f
  | useVerb      = printf "\\%s{\\verb|%s|}" (fonts !! f)
  | otherwise = printf "\\%s{%s}" (fonts !! f)
  where fonts = [ "Huge"
                , "huge"
                , "LARGE"
                , "Large"
                , "large"
                , "normalsize"
                , "small"
                , "footnotesize"
                , "scriptsize"
                , "tiny" 
                ] :: [String]

texify :: Bool -> Int -> [Token] -> Parakeet Text
texify useVerb offset tokens = T.concat <$> mapM singleTexify tokens
  where
    mainFont = fixFont $ 4 + offset
    rubyFont = fixFont $ 6 + offset
    romajiFont = fixFont $ 5 + offset
    fixFont f | f < 0 = 0
              | f > 9 = 9
              | otherwise = f
    singleTexify :: Token -> Parakeet Text
    singleTexify d = case d of
      Line         -> return " \\\\ \n"
      Break        -> do
        showBreak <- asks optShowBreak
        return $ if showBreak
          then "\\, "
          else T.empty
      Lit s        -> return $ T.pack $ build useVerb mainFont s ++ " "
      Kanji k h r  -> return $ T.pack $ printf "\\ruby{%s%s}{%s} " (build False mainFont k) (build False rubyFont ("(" ++ concat h ++ ")")) (build False romajiFont (unwords r))
      Hiragana h r -> return $ T.pack $ printf "\\ruby{%s}{%s} " (build False mainFont h) (build False romajiFont (unwords r))
      Katakana k r -> return $ T.pack $ printf "\\ruby{%s}{%s} " (build False mainFont k) (build False romajiFont (unwords r))

texifyTitle :: [Token] -> Parakeet Text
texifyTitle title = do
  tex <- texify False (-2) title
  return $ T.pack $ printf "\\title{%s}" (T.unpack tex)

texifyAuthor :: [Token] -> Parakeet Text
texifyAuthor author = do
  tex <- texify False 1 author
  return $ T.pack $ printf "\\author{%s}" (T.unpack tex)

texBare :: (Maybe MetaInfo, [Token]) -> Parakeet Text
texBare (meta, tokens) = do
  title  <- maybe (return T.empty) (texifyTitle . getTitle) meta
  author <- maybe (return T.empty) (texifyAuthor . getLitAuthor) meta
  body   <- texify True 0 tokens
  return $ T.concat [header, "\n\n", title, "\n", author, "\n\n", body]

tex :: (Maybe MetaInfo, [Token]) -> Parakeet Text
tex (meta, tokens) = do
  title  <- maybe (return T.empty) (texifyTitle . getTitle) meta
  -- TODO: using lit author is workaround, since ruby is not well supported in \author{ }
  author <- maybe (return T.empty) (texifyAuthor . getLitAuthor) meta
  let date = maybe T.empty (const "\\date{ }") meta
  body   <- texify True 0 tokens
  return $ T.unlines $ flip fmap tmpl $ \t -> 
    case t of
      "$metainfo$" -> T.concat [title, "\n", author, "\n", date]
      "$body$"     -> maybe T.empty (const "\\maketitle\n\n") meta `T.append` body
      _            -> t 
  where tmpl = header : map (T.filter (/= '\r')) (T.lines template)

